<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[Leetcode] 1. Two Sum</title>
    <url>/2020/09/05/1-TwoSum/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><em>
Given nums = [2, 7, 11, 15], target = 9,

<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</em></p>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           map.put(nums[i], i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(complement) &amp;&amp; map.get(complement) != i)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(complement)&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Video-Explaination-from-Youtuber-“Nick-White”"><a href="#Video-Explaination-from-Youtuber-“Nick-White”" class="headerlink" title="Video Explaination from Youtuber “Nick White”"></a>Video Explaination from Youtuber “Nick White”</h3><div class="video-container"><iframe src="https://www.youtube.com/embed/BoHO04xVeU0" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><p><a href="https://leetcode.com/problems/two-sum/discuss/3/Accepted-Java-O(n)-Solution">https://leetcode.com/problems/two-sum/discuss/3/Accepted-Java-O(n)-Solution</a></p>
</blockquote>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 17. Letter Combinations of a Phone Number</title>
    <url>/2020/09/05/17-letter-combinations/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="/images/letter_combination_1.png"></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><em>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</em></p>
<a id="more"></a>
<p>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String[] letterMap = &#123;<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        findCombination(digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findCombination</span><span class="params">(String digits, <span class="keyword">int</span> index, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">            res.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = digits.charAt(index);</span><br><span class="line">        </span><br><span class="line">        String letters = letterMap[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++)&#123;</span><br><span class="line">            findCombination(digits, index + <span class="number">1</span>, s + letters.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 3. Longest Substring Without Repeating Characters</title>
    <url>/2020/09/05/3-longest-substring-without-repeating-char/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p><em>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3. </em></p>
<a id="more"></a>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p><em>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</em></p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><p><em>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</em></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, </span></span><br><span class="line"><span class="comment">and keep two pointers which define the max substring. move the right pointer to scan through the string , </span></span><br><span class="line"><span class="comment">and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to </span></span><br><span class="line"><span class="comment">the right of the same character last found. Note that the two pointers can only move forward.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;s.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                j = Math.max(j,map.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashable</tag>
        <tag>two pointer</tag>
        <tag>string</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 100. Same Tree</title>
    <url>/2020/09/06/leetcode-100-sameTree/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (p.val == q.val) &amp;&amp; isSameTree(p.left, q.left)</span><br><span class="line">        &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 101. Symmetric Tree</title>
    <url>/2020/09/06/leetcode-101-symmetricTree/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">But the following [1,2,2,null,3,null,3] is not:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//recursive solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode node1, TreeNode node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (node1.val == node2.val) &amp;&amp; isMirror(node1.left, node2.right)</span><br><span class="line">        &amp;&amp; isMirror(node1.right, node2.left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Stack</tag>
        <tag>Iterative</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 102. Binary Tree Level Order Traversal</title>
    <url>/2020/09/06/leetcode-102-binary-tree-level-order/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its level order traversal as:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;Pair&lt;TreeNode,Integer&gt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> Pair&lt;TreeNode, Integer&gt; (root, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Pair&lt;TreeNode,Integer&gt; front = queue.removeFirst();</span><br><span class="line">            TreeNode node = front.getKey();</span><br><span class="line">            <span class="keyword">int</span> level = front.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(level == res.size())&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.get(level).add(node.val);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.addLast(<span class="keyword">new</span> Pair&lt;TreeNode, Integer&gt;(node.left, level + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.addLast(<span class="keyword">new</span> Pair&lt;TreeNode, Integer&gt;(node.right, level + <span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Queue</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 112. Path Sum</title>
    <url>/2020/09/20/leetcode-112-path-sum/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>A leaf is a node with no children.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the below binary tree and sum &#x3D; 22,</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br><span class="line"></span><br><span class="line">return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> hasPath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        dfs(root, sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count + node.val == sum)&#123;</span><br><span class="line">                hasPath = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        count += node.val;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(node.left, sum, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(node.right, sum, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 113. Path Sum II</title>
    <url>/2020/09/20/leetcode-113-path-sum-2/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>A leaf is a node with no children.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given the below binary tree and sum &#x3D; 22,</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        dfs(root, sum, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span> &amp; node.val == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                dfs(node.left, target - node.val, res, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                dfs(node.right, target - node.val, res, path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 118. Pascal’s Triangle</title>
    <url>/2020/09/06/leetcode-118-pascals-triangle/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.<br><img src="/images/pascal-triangle-1.gif"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//base case 1: row numebr is 0;</span></span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> triangle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//base case 2: first row</span></span><br><span class="line">        triangle.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        triangle.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; prevRow = triangle.get(i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//first element always 1;</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                row.add(prevRow.get(j-<span class="number">1</span>) + prevRow.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//last element always 1;</span></span><br><span class="line">            row.add(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">            <span class="comment">//add row to triangle;</span></span><br><span class="line">            triangle.add(row);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> triangle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 118. Pascal’s Triangle II</title>
    <url>/2020/09/07/leetcode-119-pascal-triangle-2/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.<br><img src="/images/pascal-triangle-1.gif"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><em>Input: 3<br>Output: [1,3,3,1]</em><br></p>
<a id="more"></a>
<p><strong>Follow up</strong>:<br>Could you optimize your algorithm to use only O(k) extra space?</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//base case: first row</span></span><br><span class="line">        triangle.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        triangle.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; prevRow = triangle.get(i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//first element always 1;</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//add number which based on the elements from prev row</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                row.add(prevRow.get(j-<span class="number">1</span>) + prevRow.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//last element always 1;</span></span><br><span class="line">            row.add(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">            <span class="comment">//add row to triangle;</span></span><br><span class="line">            triangle.add(row);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> triangle.get(rowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 121. Best Time to Buy and Sell Stock</title>
    <url>/2020/09/07/leetcode-121-best-time-buy-sell-stock/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Say you have an array for which the i th element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: [7,1,5,3,6,4]<br>
Output: 5<br>
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: [7,6,4,3,1]<br>
Output: 0 <br>
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 122. Best Time to Buy and Sell Stock II</title>
    <url>/2020/09/07/leetcode-122-best-time-buys-sell-stock-2/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Say you have an array prices for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note</strong>: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: [7,1,5,3,6,4]<br>
Output: 7<br>
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: [1,2,3,4,5]<br>
Output: 4 <br>
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
</em>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: [7,6,4,3,1]<br>
Output: 0<br>
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><img src="/images/122_maxprofit_1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valley = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> peak = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; prices.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// find next local minimum</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            valley = prices[i];</span><br><span class="line">            <span class="comment">// find next local maximum</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            peak = prices[i];</span><br><span class="line">            maxprofit += peak - valley;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp solution</span></span><br><span class="line"><span class="comment">//The action we can do on ith day is either buy </span></span><br><span class="line"><span class="comment">//(if last action is sell), or sell (if last action is buy), </span></span><br><span class="line"><span class="comment">//or do nothing (not buy, not sell).</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;                        </span><br><span class="line">        <span class="keyword">int</span> n = A.length, lastBuy = -A[<span class="number">0</span>], lastSold = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                                </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curBuy = Math.max(lastBuy, lastSold - A[i]);</span><br><span class="line">            <span class="keyword">int</span> curSold = Math.max(lastSold, lastBuy + A[i]);</span><br><span class="line">            lastBuy = curBuy;</span><br><span class="line">            lastSold = curSold;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lastSold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 130. Surrounded Regions</title>
    <url>/2020/09/11/leetcode-130-surrounded-regions/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line"></span><br><span class="line">After running your function, the board should be:</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">Surrounded regions shouldn’t be on the border,</span><br><span class="line">which means that any &#39;O&#39; on the border of the board are not </span><br><span class="line">flipped to &#39;X&#39;. Any &#39;O&#39; that is not on the border and it is not </span><br><span class="line">connected to an &#39;O&#39; on the border will be flipped to &#39;X&#39;. </span><br><span class="line">Two cells are connected if they are adjacent cells connected horizontally or vertically.</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++)&#123;</span><br><span class="line">                <span class="comment">//check from the border, if there is &#x27;O&#x27; at border, do dfs </span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || i == board.length-<span class="number">1</span> || j == <span class="number">0</span>|| j == board[i].length - <span class="number">1</span>)&#123;   </span><br><span class="line">                    surround(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;*&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">surround</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>|| i &gt;= board.length || j &gt;= board[i].length || board[i][j]==<span class="string">&#x27;X&#x27;</span></span><br><span class="line">         || board[i][j] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;*&#x27;</span>; <span class="comment">// * represent already visited &#x27;O&#x27;s</span></span><br><span class="line">        surround(board, i - <span class="number">1</span>, j);</span><br><span class="line">        surround(board, i + <span class="number">1</span>, j);</span><br><span class="line">        surround(board, i, j - <span class="number">1</span>);</span><br><span class="line">        surround(board, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 134. Gas Station</title>
    <url>/2020/09/07/leetcode-134-gas-station/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].<br>You have a car with an unlimited gas tank and it costs cost[i]of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.<br>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p>Note:<br>If there exists a solution, it is guaranteed to be unique.<br>Both input arrays are non-empty and have the same length.<br>Each element in the input arrays is a non-negative integer.</p>
<a id="more"></a>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

<p>Output: 3</p>
<p>Explanation:<br>Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 4. Your tank = 4 - 1 + 5 = 8<br>Travel to station 0. Your tank = 8 - 2 + 1 = 7<br>Travel to station 1. Your tank = 7 - 3 + 2 = 6<br>Travel to station 2. Your tank = 6 - 4 + 3 = 5<br>Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.<br>Therefore, return 3 as the starting index.</em></p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: 
gas  = [2,3,4]
cost = [3,4,3]

<p>Output: -1</p>
<p>Explanation:<br>You can’t start at station 0 or 1, as there is not enough gas to travel to the next station.<br>Let’s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 0. Your tank = 4 - 3 + 2 = 3<br>Travel to station 1. Your tank = 3 - 3 + 3 = 3<br>You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.<br>Therefore, you can’t travel around the circuit once no matter where you start.</em></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * solution</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>; <span class="comment">//gas consume and added at current positin</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>; <span class="comment">// diff between gas consumed and added in total</span></span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>;  <span class="comment">// gas remaining in gas tank</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// start index;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cost.length; i++)&#123;</span><br><span class="line">            cur = gas[i] - cost[i];</span><br><span class="line">            tank += cur;</span><br><span class="line">            <span class="comment">//if gas tank &lt; 0 which means we cannot start from this position</span></span><br><span class="line">            <span class="comment">//because the gas remaining in the tank cannot suppport us to reach next</span></span><br><span class="line">            <span class="comment">//position</span></span><br><span class="line">            <span class="comment">//so we move start point to next position, and reset the tank</span></span><br><span class="line">            <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                index = i + <span class="number">1</span>;</span><br><span class="line">                tank = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            total += cur;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//check if we can do round trip</span></span><br><span class="line">        <span class="keyword">return</span> total &lt; <span class="number">0</span>? -<span class="number">1</span> : index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 141. Linked List Cycle</title>
    <url>/2020/09/07/leetcode-141-linedlist-cycle/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If posis -1, then there is no cycle in the linked list.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p><em>Input: head = [3,2,0,-4], pos = 1<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.</em><br><img src="/images/linkedlist-cycle.png"></p>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: head = [1,2], pos = 0<br>
Output: true<br>
Explanation: There is a cycle in the linked list, where tail connects to the first node.</em>

<p><img src="/images/linkedlist-cycle-2.png"></p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: head = [1], pos = -1<br>
Output: false<br>
Explanation: There is no cycle in the linked list.</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  walker and runner,good metaphor.</span></span><br><span class="line"><span class="comment">// Walker goes 1 step at a time,and runner goes 2 steps at a time.</span></span><br><span class="line"><span class="comment">// If we think walker is still,then runner goes 1 step at a time.</span></span><br><span class="line"><span class="comment">// So,the problem is just like a Chasing problem.</span></span><br><span class="line"><span class="comment">// There is a time when runner catches walker.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode walker = head;</span><br><span class="line">        ListNode runner = head;</span><br><span class="line">        <span class="keyword">while</span>(runner.next != <span class="keyword">null</span> &amp;&amp; runner.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            walker = walker.next;</span><br><span class="line">            runner = runner.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(walker == runner)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 144. Binary Tree Preoder Traversal</title>
    <url>/2020/09/07/leetcode-144-binaryTree-preorder/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//recursive method</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.add(node.val);</span><br><span class="line">            preorder(node.left, res);</span><br><span class="line">            preorder(node.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//iterative method with stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 145. Binary Tree Postorder Traversal</title>
    <url>/2020/09/07/leetcode-145-binaryTree-postOrder/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//recursive solution</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.left, res);</span><br><span class="line">        postorder(node.right, res);</span><br><span class="line"></span><br><span class="line">        res.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//iterative solution</span></span><br><span class="line"><span class="comment">//use linkedlist&#x27;s addFirst()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            res.addFirst(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 151. Reverse Words in a String</title>
    <url>/2020/09/07/leetcode-151-reverse-words/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an input string, reverse the string word by word.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: "the sky is blue"<br>
Output: "blue is sky the"
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: "  hello world!  "<br>
Output: "world! hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
</em>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: "a good   example"<br>
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//solution using regex and spit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        String[] list = s.trim().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">         <span class="keyword">if</span>(list.length != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = list.length -<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">                sb.append(list[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">             sb.append(list[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 169. Majority Element</title>
    <url>/2020/09/07/leetcode-169-majority-element/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: [3,2,3]
Output: 3
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: [2,2,1,1,1,2,2]
Output: 2
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Hashtable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer key: map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) &gt; (nums.length / <span class="number">2</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sorting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bit manipulation </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bit = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) </span><br><span class="line">            <span class="keyword">if</span> ((num&gt;&gt;(<span class="number">31</span>-i) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                bit[i]++;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">        bit[i]=bit[i]&gt;nums.length/<span class="number">2</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        ret += bit[i]*(<span class="number">1</span>&lt;&lt;(<span class="number">31</span>-i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>HashMap</tag>
        <tag>bit-manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 189. Rotate Array</title>
    <url>/2020/09/07/leetcode-189-rotate-array/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: nums = [1,2,3,4,5,6,7], k = 3<br>
Output: [5,6,7,1,2,3,4]<br>
Explanation:<br>
rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>
rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>
rotate 3 steps to the right: [5,6,7,1,2,3,4]<br>
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: nums = [-1,-100,3,99], k = 2<br>
Output: [3,99,-1,-100]<br>
Explanation: <br>
rotate 1 steps to the right: [99,-1,-100,3]<br>
rotate 2 steps to the right: [3,99,-1,-100]<br>
</em>

<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><em>
* 1 <= nums.length <= 2 * 10^4<br>
* It's guaranteed that nums[i] fits in a 32 bit-signed integer.<br>
* k >= 0<br>
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * intuitive way to solve this question</span></span><br><span class="line"><span class="comment"> * //nums = [1,2,3,4,5,6,7], k = 3</span></span><br><span class="line"><span class="comment"> * reverse whole array: 7 6 5 4 3 2 1;</span></span><br><span class="line"><span class="comment"> * reverse array from index 0 to k - 1 (2);</span></span><br><span class="line"><span class="comment"> * -&gt; 5 6 7 4 3 2 1</span></span><br><span class="line"><span class="comment"> * reverse array from k to end;</span></span><br><span class="line"><span class="comment"> * -&gt; 5 6 7 1 2 3 4</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k% nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span> , k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k , nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * brute force solution</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="comment">//nums = [1,2,3,4,5,6,7], k = 3</span></span><br><span class="line"> <span class="comment">// i = 0:</span></span><br><span class="line"> <span class="comment">//nums = [7,2,3,4,5,6,1]</span></span><br><span class="line"> <span class="comment">//-&gt; [7,1,3,4,5,6,2] -&gt; [7,1,2,4,5,6,3] -&gt; [7,1,2,3,5,6,4] -&gt; [7,1,2,3,4,6,5]</span></span><br><span class="line"> <span class="comment">//-&gt; [7,1,2,3,4,5,6]</span></span><br><span class="line"> <span class="comment">// i = 1: -&gt; [6,1,2,3,4,5,7] -&gt;[6,7,2,3,4,5,1] -&gt; [6,7,1,3,4,5,2]</span></span><br><span class="line"> <span class="comment">//-&gt;[6,7,1,2,4,5,3] -&gt;[6,7,1,2,3,5,4] -&gt; [6,7,1,2,3,4,5]</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="comment">//-&gt; [5,6,7,1,2,3,4]</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k% nums.length;</span><br><span class="line">        <span class="comment">//brute force solution</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> prev = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = prev;</span><br><span class="line">                prev = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 200. Number of Islands</title>
    <url>/2020/09/07/leetcode-200-number-of-islands/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y;          <span class="comment">// The height of the given grid</span></span><br><span class="line">    <span class="keyword">int</span> x;          <span class="comment">// The width of the given grid</span></span><br><span class="line">    <span class="keyword">char</span>[][] g;     <span class="comment">// The given grid, stored to reduce recursion memory usage</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given a 2d grid map of &#x27;1&#x27;s (land) and &#x27;0&#x27;s (water),</span></span><br><span class="line"><span class="comment">     * count the number of islands.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * This method approaches the problem as one of depth-first connected</span></span><br><span class="line"><span class="comment">     * components search</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid, the given grid.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of islands.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Store the given grid</span></span><br><span class="line">        <span class="comment">// This prevents having to make copies during recursion</span></span><br><span class="line">        g = grid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Our count to return</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Dimensions of the given graph</span></span><br><span class="line">        y = g.length;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x = g[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Iterate over the entire given grid</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dfs(i, j);</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Marks the given site as visited, then checks adjacent sites.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Or, Marks the given site as water, if land, then checks adjacent sites.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Or, Given one coordinate (i,j) of an island, obliterates the island</span></span><br><span class="line"><span class="comment">     * from the given grid, so that it is not counted again.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i, the row index of the given grid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j, the column index of the given grid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check for invalid indices and for sites that aren&#x27;t land</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= y || j &lt; <span class="number">0</span> || j &gt;= x || g[i][j] != <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Mark the site as visited</span></span><br><span class="line">        g[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check all adjacent sites</span></span><br><span class="line">        dfs(i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 205. Isomorphic Strings</title>
    <url>/2020/09/07/leetcode-205-isomorphic-strings/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given two strings s and t, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: s = "egg", t = "add"<br>
Output: true
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: s = "foo", t = "bar"<br>
Output: false
</em>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: s = "paper", t = "title"<br>
Output: true
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">     HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">         <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(!map.containsKey(c))&#123;</span><br><span class="line">           <span class="comment">//check if two chars map to same value</span></span><br><span class="line">             <span class="keyword">if</span>(!set.contains(t.charAt(i)))&#123;</span><br><span class="line">                 map.put(c, t.charAt(i));</span><br><span class="line">                 set.add(t.charAt(i));</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(map.get(c) != t.charAt(i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 206. Reverse Linked List</title>
    <url>/2020/09/07/leetcode-206-reverse-linkedlist/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Reverse a singly linked list.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><em>
Input: 1->2->3->4->5->NULL<br>
Output: 5->4->3->2->1->NULL
</em>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iterative solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//two pointers</span></span><br><span class="line">        </span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//revert the &quot;next&quot; pointer of current node</span></span><br><span class="line">          <span class="comment">//to previous node, and move both &quot;prev&quot; and &quot;cur&quot;</span></span><br><span class="line">          <span class="comment">//pointer to next position</span></span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//recursive </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">// initial:</span></span><br><span class="line"><span class="comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// after reverseList(2):</span></span><br><span class="line"><span class="comment">// 1 -&gt; 2 &lt;- 3 &lt;- 4 &lt;- 5</span></span><br><span class="line"><span class="comment">//      |</span></span><br><span class="line"><span class="comment">//      v</span></span><br><span class="line"><span class="comment">//     null</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// after operate on 1:</span></span><br><span class="line"><span class="comment">// null &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5   </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode newHead = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 21. Merge Two Sorted Lists</title>
    <url>/2020/09/06/leetcode-21-merge-two-sorted-list/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><em>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</em></p>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//recusive way</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">       <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">       <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">           l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//iterative</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       ListNode cur = dummyHead;</span><br><span class="line">       <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">               cur.next = l1;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur.next = l2;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">           cur.next = l1;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">          cur.next = l2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 216. Combination Sum III</title>
    <url>/2020/09/18/leetcode-216-combination-sum-3/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:</p>
<ul>
<li>Only numbers 1 through 9 are used.</li>
<li>Each number is used at most once.<br>Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.</li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">Output: [[1,2,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 4 &#x3D; 7</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">Output: [[1,2,6],[1,3,5],[2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 6 &#x3D; 9</span><br><span class="line">1 + 3 + 5 &#x3D; 9</span><br><span class="line">2 + 3 + 4 &#x3D; 9</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 4, n &#x3D; 1</span><br><span class="line">Output: []</span><br><span class="line">Explanation: There are no valid combinations. [1,2,1] is not valid because 1 is used twice.</span><br></pre></td></tr></table></figure>

<h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 2</span><br><span class="line">Output: []</span><br><span class="line">Explanation: There are no valid combinations.</span><br></pre></td></tr></table></figure>

<h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5"></a>Example 5</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k &#x3D; 9, n &#x3D; 45</span><br><span class="line">Output: [[1,2,3,4,5,6,7,8,9]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 &#x3D; 45</span><br><span class="line">​​​​​​​There are no other valid combinations.</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        backtracking(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k &amp;&amp; sum == n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(res, path, k, n, i + <span class="number">1</span>, sum + i);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 219. Contains Duplicate II</title>
    <url>/2020/09/07/leetcode-219-contains-duplicate-2/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array of integers and an integer k, find out whether there are two distinct indices iand j in the array such that nums[i] = nums[j] and the absolute difference between i and jis at most k.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: nums = [1,2,3,1], k = 3<br>
Output: true
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: nums = [1,0,1,1], k = 1<br>
Output: true
</em>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: nums = [1,2,3,1,2,3], k = 2<br>
Output: false
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; record = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i  &lt; nums.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            record.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(record.size() == k + <span class="number">1</span>)&#123;</span><br><span class="line">                record.remove(nums[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 217. Contains Duplicate</title>
    <url>/2020/09/07/leetcode-217-contains-duplicate/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: [1,2,3,1] <br>
Output: true
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: [1,2,3,4]<br>
Output: false
</em>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: [1,1,1,3,3,4,3,2,4,2]<br>
Output: true
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//solution with sorting</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>] == nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hashtable solution 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           map.put(nums[i], i); </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">          <span class="comment">//we have to make sure it is not itself</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]) &amp;&amp; map.get(nums[i]) != i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hashtable solution 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>); </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i]) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
        <tag>array</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 226. Invert Binary Tree</title>
    <url>/2020/09/07/leetcode-226-invert-binaryTree/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Invert a binary tree.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tempRight = root.right;</span><br><span class="line">        root.right = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(tempRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution 3: iterative BFS</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">final</span> TreeNode left = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = left;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 220. Contains Duplicate III</title>
    <url>/2020/09/08/leetcode-220-contains-duplicate-3/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: nums = [1,2,3,1], k = 3, t = 0<br>
Output: true
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: nums = [1,0,1,1], k = 1, t = 2<br>
Output: true
</em>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: nums = [1,5,9,1,5,9], k = 2, t = 3<br>
Output: false
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> number = (<span class="keyword">long</span>) nums[i];</span><br><span class="line">            Long ceiling = set.ceiling(number);</span><br><span class="line">            Long floor = set.floor(number);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((floor != <span class="keyword">null</span> &amp;&amp; number - floor &lt;= t) ||(</span><br><span class="line">              ceiling != <span class="keyword">null</span> &amp;&amp; ceiling - number &lt;= t))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            set.add(number);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(set.size() == k + <span class="number">1</span>)&#123;</span><br><span class="line">                set.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 237. Delete Node in a Linked List</title>
    <url>/2020/09/07/leetcode-237-delete-node-in-linkedlist/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:<br><img src="/images/237-deleteNode.png"></p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: head = [4,5,1,9], node = 5<br>
Output: [4,1,9]<br>
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: head = [4,5,1,9], node = 1<br>
Output: [4,5,9]<br>
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
</em>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><em>
1. The linked list will have at least two elements.<br>
2. All of the nodes' values will be unique.<br>
3. The given node will not be the tail and it will always be a valid node of the linked list.<br>
4. Do not return anything from your function.<br>
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">           node = <span class="keyword">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">            ListNode node2 = node.next;</span><br><span class="line">            node.val = node2.val;</span><br><span class="line">            node.next = node2.next;</span><br><span class="line">            node2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 26. Remove Duplicates from Sorted Array</title>
    <url>/2020/09/06/leetcode-26-remove-duplicates-from-sorted-array/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a sorted array nums, remove the duplicates in-placesuch that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p><em>Given nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</em></p>
<a id="more"></a>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p><em>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>
<p>It doesn’t matter what values are set beyond the returned length.</em></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two pointer solution</span></span><br><span class="line"><span class="comment"> * with O(n) time complexiy and O(1) space complexity</span></span><br><span class="line"><span class="comment"> * **/</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[slow] != nums[i])&#123;</span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 27. Remove Element</title>
    <url>/2020/09/06/leetcode-27-remove-elemenet/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p><em>Given nums = [3,2,2,3], val = 3,</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>It doesn’t matter what you leave beyond the returned length.</em></p>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p><em>Given nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
<p>Note that the order of those five elements can be arbitrary.</p>
<p>It doesn’t matter what values are set beyond the returned length.</em></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two Pointer Solution</span></span><br><span class="line"><span class="comment"> * fast-slow pointer</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>; i  &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">                nums[slow] = nums[i];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 274. H-Index</title>
    <url>/2020/09/07/leetcode-274-h-index/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her Npapers have at least h citations each, and the other N − h papers have no more than hcitations each.”</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><em>
Input: citations = [3,0,6,1,5]<br>
Output: 3 <br>
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had 
             received 3, 0, 6, 1, 5 citations respectively. 
             Since the researcher has 3 papers with at least 3 citations each and the remaining 
             two with no more than 3 citations each, her h-index is 3.
</em>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        <span class="keyword">int</span> n = citations.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; citations.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n - i &lt;= citations[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> n - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 275. H-Index II</title>
    <url>/2020/09/07/leetcode-275-h-index-2/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><em>
Input: citations = [0,1,3,5,6]<br>
Output: 3 <br>
Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had 
             received 0, 1, 3, 5, 6 citations respectively. 
             Since the researcher has 3 papers with at least 3 citations each and the remaining 
             two with no more than 3 citations each, her h-index is 3.
</em>
<a id="more"></a>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><em>
If there are several possible values for h, the maximum one is taken as the h-index.
</em>

<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up"></a>Follow up</h3><ul>
<li>This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order.</li>
<li>Could you solve it in logarithmic time complexity?</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//binary search solution</span></span><br><span class="line"><span class="comment">//with O(logN) time complexity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = citations.length;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[mid] == n - mid) <span class="keyword">return</span> n - mid;</span><br><span class="line">            <span class="keyword">if</span>(citations[mid] &gt; n - mid) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 279. Perfect Squares</title>
    <url>/2020/09/07/leetcode-279-perfect-squares/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: n = 12 <br>
Output: 3 <br>
Explanation: 12 = 4 + 4 + 4.
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: n = 13<br>
Output: 2<br>
Explanation: 13 = 4 + 9.
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       q.offer(n);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">       Set&lt;Integer&gt; holder = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = q.poll();</span><br><span class="line">                holder.add(num);</span><br><span class="line">                visited.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            step++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : holder) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j * j == i) &#123;</span><br><span class="line">                        <span class="keyword">return</span> step;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!visited.contains(i - j * j)) &#123;</span><br><span class="line">                        q.offer(i - j * j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            holder.clear();</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 28. Implement strStr()</title>
    <url>/2020/09/06/leetcode-28-implement-strstr/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: haystack = "hello", needle = "ll"
Output: 2</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: haystack = "aaaaa", needle = "bba"
Output: -1</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//use indexOf() funtion </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution similiar to sliding window</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = haystack.length();</span><br><span class="line">            <span class="keyword">int</span> len = needle.length();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len + <span class="number">1</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.substring(i, i + len).equals(needle))&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 283. Move Zeroes</title>
    <url>/2020/09/07/leetcode-283-move-zeros/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><em>
Input: [0,1,0,3,12]<br>
Output: [1,3,12,0,0]
</em>
<a id="more"></a>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ol>
<li>You must do this in-place without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//two pointers solution</span></span><br><span class="line"><span class="comment">//only if nums[i] != 0, we can assign value to nums[slow];</span></span><br><span class="line"><span class="comment">//and then slow++;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[slow++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = slow; j &lt; nums.length; j++)&#123;</span><br><span class="line">            nums[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//solution 2:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">              swap(nums, slow++, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 290. Word Pattern</title>
    <url>/2020/09/07/leetcode-290-word-pattern/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a pattern and a string str, find if strfollows the same pattern.</p>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: pattern = "abba", str = "dog cat cat dog"<br>
Output: true
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input:pattern = "abba", str = "dog cat cat fish"<br>
Output: false
</em>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: pattern = "aaaa", str = "dog cat cat dog"<br>
Output: false
</em>

<h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h3><em>
Input: pattern = "abba", str = "dog dog dog dog" <br>
Output: false
</em>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>You may assume pattern contains only lowercase letters, and str contains lowercase letters that may be separated by a single space.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String str)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String[] strList = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(pattern.length() != strList.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = pattern.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(c))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(strList[i]))&#123;</span><br><span class="line">                    map.put(c, strList[i]);</span><br><span class="line">                    set.add(strList[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.get(c).equals(strList[i]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 299. Bulls and Cows</title>
    <url>/2020/09/07/leetcode-299-bulls-and-cows/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. </p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: secret = "1807", guess = "7810"<br>
Output: "1A3B"<br>
Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: secret = "1123", guess = "0111"<br>
Output: "1A1B"<br>
Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * solution with hashmap</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = secret.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == guess.charAt(i))&#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; guess.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = guess.charAt(i);</span><br><span class="line">           <span class="keyword">if</span>(c != secret.charAt(i) &amp;&amp; map.containsKey(c) &amp;&amp; map.get(c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               b++;</span><br><span class="line">               map.put(c, map.get(c) - <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a+<span class="string">&quot;A&quot;</span>+b+<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * two bucket solution</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bull = <span class="number">0</span>, cow = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] sarr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] garr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(secret.charAt(i) != guess.charAt(i))&#123;</span><br><span class="line">                sarr[secret.charAt(i)-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">                garr[guess.charAt(i)-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bull++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            cow += Math.min(sarr[i], garr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (bull + <span class="string">&quot;A&quot;</span> + cow + <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 309. Best Time to Buy and Sell Stock with Cooldown</title>
    <url>/2020/09/08/leetcode-309-best-time-buy-sell-stock-cooldown/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Say you have an array for which the i th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) <br></li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><em>
Input: [1,2,3,0,2]<br>
Output: 3 <br>
Explanation: transactions = [buy, sell, cooldown, buy, sell]
</em>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s0 = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length]; <span class="comment">// Stay at s0, or rest from s2</span></span><br><span class="line">        <span class="keyword">int</span>[] s1 = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length]; <span class="comment">// Stay at s1, or buy from s0</span></span><br><span class="line">        <span class="keyword">int</span>[] s2 = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length]; <span class="comment">// Only one way from s1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        s1[<span class="number">0</span>] = - prices[<span class="number">0</span>]; <span class="comment">// After buy, you should have -prices[0] profit. Be positive!</span></span><br><span class="line">        s0[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// At the start, you don&#x27;t have any stock if you just rest</span></span><br><span class="line">		s2[<span class="number">0</span>] = Integer.MIN_VALUE; <span class="comment">// Lower base case</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">			s0[i] = Math.max(s0[i - <span class="number">1</span>], s2[i - <span class="number">1</span>]);</span><br><span class="line">			s1[i] = Math.max(s1[i - <span class="number">1</span>], s0[i - <span class="number">1</span>] - prices[i]);</span><br><span class="line">			s2[i] = s1[i - <span class="number">1</span>] + prices[i];</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(s0[prices.length - <span class="number">1</span>], s2[prices.length - <span class="number">1</span>]);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 31. Next Permutation</title>
    <url>/2020/09/19/leetcode-31-next-permutation/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> replace = nums.length -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(replace &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[replace] &lt; nums[replace + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            replace--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(replace &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//replace cur number with closest larger number</span></span><br><span class="line">        <span class="keyword">int</span> lgIndex = replace + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lgIndex &lt; nums.length &amp;&amp; nums[lgIndex] &gt; nums[replace])&#123;</span><br><span class="line">            lgIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[replace];</span><br><span class="line">        nums[replace] = nums[lgIndex - <span class="number">1</span>];</span><br><span class="line">        nums[lgIndex - <span class="number">1</span>] = tmp;</span><br><span class="line">        Arrays.sort(nums, replace + <span class="number">1</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div class="video-container"><iframe src="https://www.youtube.com/embed/quAS1iydq7U" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 344. Reverse String</title>
    <url>/2020/09/07/leetcode-344-reverse-string/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Write a function that reverses a string. The input string is given as an array of characters char[].</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>You may assume all the characters consist of printable ascii characters.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: ["h","e","l","l","o"]<br>
Output: ["o","l","l","e","h"]
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: ["H","a","n","n","a","h"]<br>
Output: ["h","a","n","n","a","H"]
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//two pointers solution</span></span><br><span class="line"><span class="comment">//O(1) space complexity </span></span><br><span class="line"><span class="comment">//O(n) time complexity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 345. Reverse Vowels of a String</title>
    <url>/2020/09/07/leetcode-345-reverse-vowels-of-string/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: "hello" <br>
Output: "holle"
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: "leetcode" <br>
Output: "leotcede"
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//two pointer solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String vowels = <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> end = chars.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end &amp;&amp; vowels.indexOf(chars[start]) == -<span class="number">1</span>)&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end &amp;&amp; vowels.indexOf(chars[end]) == -<span class="number">1</span>)&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//swap</span></span><br><span class="line">            Character temp = chars[start];</span><br><span class="line">            chars[start] = chars[end];</span><br><span class="line">            chars[end] = temp;</span><br><span class="line"></span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>string</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 36. Valid Sudoku</title>
    <url>/2020/09/20/leetcode-36-valid-sudoku/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<ul>
<li>Each row must contain the digits 1-9 without repetition.</li>
<li>Each column must contain the digits 1-9 without repetition.</li>
<li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.<br><img src="/images/Sudoku.png"><br>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being </span><br><span class="line">    modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
<li>The given board contain only digits 1-9 and the character ‘.’.</li>
<li>The given board size is always 9x9.</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            HashSet&lt;Character&gt; rows = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            HashSet&lt;Character&gt; columns = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span> &amp;&amp; !rows.add(board[i][j]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[j][i]!=<span class="string">&#x27;.&#x27;</span> &amp;&amp; !columns.add(board[j][i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;            </span><br><span class="line">             &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>;i += <span class="number">3</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">7</span>; j += <span class="number">3</span>)&#123;</span><br><span class="line">               HashSet&lt;Character&gt; cube = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">9</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i + k/<span class="number">3</span>][j + k % <span class="number">3</span>]!=<span class="string">&#x27;.&#x27;</span> &amp;&amp; !cube.add(board[i + k/<span class="number">3</span>][j + k % <span class="number">3</span>]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 377. Combination Sum IV</title>
    <url>/2020/09/19/leetcode-377-combination-sum-4/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">target &#x3D; 4</span><br><span class="line"></span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">Note that different sequences are counted as different combinations.</span><br><span class="line"></span><br><span class="line">Therefore the output is 7.</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">               <span class="keyword">if</span>(num &gt; i) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == i)&#123;</span><br><span class="line">                   dp[i] += <span class="number">1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   dp[i] += dp[i - num];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 383. Ransom Note</title>
    <url>/2020/09/07/leetcode-383-ransom-note/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Input: ransomNote = "a", magazine = "b"<br>
Output: false
</em>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: ransomNote = "aa", magazine = "ab"<br>
Output: false
</em>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: ransomNote = "aa", magazine = "aab" <br>
Output: true
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hashtable solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = magazine.charAt(i);</span><br><span class="line">            <span class="comment">//increment value by 1 for counter of that character </span></span><br><span class="line">            count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = ransomNote.charAt(i);</span><br><span class="line">            <span class="comment">//check if characters in ransom exist in magazine</span></span><br><span class="line">            <span class="keyword">if</span>(count[c -<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)&#123; <span class="comment">// if counter[c -&#x27;a&#x27;] == 0, which means that char in </span></span><br><span class="line">            <span class="comment">//ransom not exist in magazine or it exist in magazine but number of character more than</span></span><br><span class="line">            <span class="comment">//the character exist in magazine</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//decrement counter by 1 every time we find same character in magazine</span></span><br><span class="line">                count[c -<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 387. First Unique Character in a String</title>
    <url>/2020/09/07/leetcode-387-first-unique-char-in-string/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><em>
s = "leetcode"<br>
return 0.<br>
s = "loveleetcode",<br>
return 2.<br>
</em>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hashtable solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 39. Combination Sum</title>
    <url>/2020/09/18/leetcode-39-combination-sum/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>The same repeated number may be chosen from candidates unlimited number of times.<br><strong>Note</strong></p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res  = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(res, path, nums, target, sum + nums[i], i);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 40. Combination Sum II</title>
    <url>/2020/09/18/leetcode-40-combination-sum-2/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>
<p>Each number in candidates may only be used once in the combination.<br><strong>Note</strong></p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*if &quot;(i &gt; index &amp;&amp; nums[i] == nums[i-1]) continue;</span></span><br><span class="line"><span class="comment">*when we should skip a number? </span></span><br><span class="line"><span class="comment">*not just it&#x27;s the same as previous number, but also when it&#x27;s previous number *haven&#x27;t been added!</span></span><br><span class="line"><span class="comment">*i &gt; cur means nums[i - 1] is not added to the path (you should know why if you understand the algorithm), </span></span><br><span class="line"><span class="comment">*so if nums[i] == nums[i-1], then we shouldn&#x27;t add nums[i].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">         List&lt;List&lt;Integer&gt;&gt; res  = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//skip duplicates</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; index &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(res, path, nums, target, sum + nums[i], i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 41. First Missing Positive</title>
    <url>/2020/09/06/leetcode-41-first-missing-positive/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p><em>Input: [1,2,0]<br>Output: 3 </em></p>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: [3,4,-1,1]
Output: 2</em>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><em>
Input: [7,8,9,11,12]
Output: 1
</em>

<h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h3><em>
Your algorithm should run in O(n) time and uses constant extra space.
</em>
## Solution
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * solution</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="comment">//nums = [ 3 4 -1 1 8 ]</span></span><br><span class="line"> <span class="comment">//nums[0] = 3, put 3 into position 3 - 1 and then swap number at index 2 and 0;</span></span><br><span class="line"> <span class="comment">// nums [ -1， 4， 3， 1， 8 ] after first swap;</span></span><br><span class="line"> <span class="comment">//nums[1] = 4, put 4 into position 3 and then swap number at index 3 and 1;</span></span><br><span class="line"> <span class="comment">// nums [ -1, 1, 3, 4, 8 ] after 2nd swap;</span></span><br><span class="line"> <span class="comment">// even after swap, we still need to check nums[1], right now, nums[1] = 1</span></span><br><span class="line"> <span class="comment">// we need to swap index 1 and 0;</span></span><br><span class="line"> <span class="comment">//so nums = [1, -1, 3, 4, 8];</span></span><br><span class="line"> <span class="comment">//nums[2] = 3, cuz position 3-1 = 2, we do not have to swap here;</span></span><br><span class="line"> <span class="comment">// nums[3] = 4.. same as before, no need to swap</span></span><br><span class="line"> <span class="comment">// nums[4] = 8 which is greater than the size of array, skip this as well</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i]- <span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n  + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 46. Permutations</title>
    <url>/2020/09/06/leetcode-46-permutations/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a collection of distinct integers, return all possible permutations.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><em>
Input: [1,2,3] <br />
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</em>

<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; track, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(track.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(track));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i ++)&#123;</span><br><span class="line">            <span class="comment">//skip option if element already exist in the track</span></span><br><span class="line">            <span class="keyword">if</span>(track.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//choose </span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//explore</span></span><br><span class="line">            backtrack(res, track, nums);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//unchoose</span></span><br><span class="line">            <span class="comment">// tempList.remove(tempList.size() - 1);</span></span><br><span class="line">            <span class="comment">// This ststement is used to remove the element whose all the subsets has been found.</span></span><br><span class="line">            <span class="comment">// Consider an example</span></span><br><span class="line">            <span class="comment">// Array -&gt; &#123;1,2,3&#125;</span></span><br><span class="line">            <span class="comment">// when we start from 1st element i.e index 0</span></span><br><span class="line">            <span class="comment">// we add all the subsets of 1 by calling backtrack( list, track, nums);</span></span><br><span class="line">            <span class="comment">// When it backtacks after adding all subsets of 1 the tempList Contains 1.</span></span><br><span class="line">            <span class="comment">// Now we need to remove it from list.</span></span><br><span class="line">            <span class="comment">// And get all the subsets of next element. (Observe all the subsets containg the currnt element and previous element have been added already.</span></span><br><span class="line">            track.remove(track.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 47. Permutations II</title>
    <url>/2020/09/06/leetcode-47-permutations-2/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><em>
Input: [1,1,2] <br />
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</em>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; track, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(track.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(track));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//explaination is below</span></span><br><span class="line">             <span class="keyword">if</span> (visited[i] || (i &gt; <span class="number">0</span> &amp;&amp; !visited[i-<span class="number">1</span>] &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            backtrack(res, track, nums, visited);</span><br><span class="line">            track.remove(track.size() - <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/permutation2-1.png"><br><img src="/images/permutation2-2.png"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 48. Rotate Image</title>
    <url>/2020/09/06/leetcode-48-rotate-image/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Note:</p>
<p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br></em></p>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]<br></em></p>
<h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><p>The idea was firstly transpose the matrix and then flip it symmetrically. For instance,</p>
<p>1  2  3<br>4  5  6<br>7  8  9<br>after transpose, it will be swap(matrix[i][j], matrix[j][i])</p>
<p>1  4  7<br>2  5  8<br>3  6  9<br>Then flip the matrix horizontally. (swap(matrix[i][j], matrix[i][matrix.length-1-j])</p>
<p>7  4  1<br>8  5  2<br>9  6  3</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.length/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][matrix.length - <span class="number">1</span> - j];</span><br><span class="line">                matrix[i][matrix.length-<span class="number">1</span>-j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 55. Jump game</title>
    <url>/2020/09/06/leetcode-55-jump-game/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><em>
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
</em>
<a id="more"></a>

<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><em>
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DP solution</span></span><br><span class="line"><span class="comment"> * with O(n^2) time complexity</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//dp solution</span></span><br><span class="line">      <span class="keyword">int</span> n = nums.length;</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">      <span class="comment">//search from back of list;</span></span><br><span class="line">      <span class="comment">// use 0 represent the non-reachable and 1 represent reachable</span></span><br><span class="line">      <span class="comment">//2 3 1 1 4</span></span><br><span class="line">      <span class="comment">//0 0 0 0 1 # at begining</span></span><br><span class="line">      <span class="comment">//0 0 0 1 1 # 2nd dp[3 + 1] == 1 then change dp[3] to 1</span></span><br><span class="line">      <span class="comment">//0 0 1 1 1 # 3rd dp[2 + 1] = dp[3] == 1 then change dp[2] to 1;</span></span><br><span class="line">      <span class="comment">//0 1 1 1 1 # 4th dp[1 + 1] = dp[2] == 1 then change dp[1] to 1;</span></span><br><span class="line">      <span class="comment">//1 1 1 1 1 # 5th dp[0 + 1] = dp[1] == 1 then change dp[0] to 1;</span></span><br><span class="line">      <span class="comment">//so index 0 is able to reach the last index;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//case 2;</span></span><br><span class="line">      <span class="comment">//3 2 1 0 4</span></span><br><span class="line">      <span class="comment">//0 0 0 0 1 # at begining </span></span><br><span class="line">      <span class="comment">//0 0 0 0 1 # 2nd dp[3 + 0 (nums[3])] = 0, dp[3] = 0;</span></span><br><span class="line">      <span class="comment">//dp[2 + 1(nums[2])] = dp[3] = 0; dp[2] = 0;</span></span><br><span class="line">      <span class="comment">//dp[1 + 1] or dp[1 + 2] both equal to 0, so dp[1] = 0;</span></span><br><span class="line">      <span class="comment">//dp[0 + 1], dp[0 + 2] and dp[0 + 3] all equal to 0, so dp[0] = 0</span></span><br><span class="line">      <span class="comment">//which means in this example, cannot jump to last if we jump from index 0</span></span><br><span class="line">      <span class="comment">//initially</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">          dp[i] = (i == n-<span class="number">1</span>)? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i + j] == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">          <span class="keyword">return</span> dp[<span class="number">0</span>] == <span class="number">1</span>? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Greedy Solution</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//greedy solution</span></span><br><span class="line">        <span class="keyword">int</span> furthest = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(furthest &lt; i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//find furthest position they can reach for each positions</span></span><br><span class="line">            furthest = Math.max(furthest, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Backtracking Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//backtracking solution</span></span><br><span class="line">        <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span>[]nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(position == nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> furthestPosition = Math.min(nums.length - <span class="number">1</span>, position + nums[position]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> nextPosition = position + <span class="number">1</span>; nextPosition &lt;= furthestPosition; nextPosition++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(canJumpFromPosition(nextPosition, nums))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
        <tag>dp</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 77. Combinations</title>
    <url>/2020/09/06/leetcode-77-combinations/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>You may return the answer in any order.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p><em>Input: n = 4, k = 2<br>Output:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</em></p>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><em>
Input: n = 1, k = 1 <br />
Output: [[1]]
</em>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, k, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; track, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(track.size() == k)&#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(track));</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">          <span class="comment">//pick an option</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            <span class="comment">//if size of track is less than k, keep tracking another path</span></span><br><span class="line">            <span class="keyword">if</span>(track.size() &lt;= k)&#123;</span><br><span class="line">                backtrack(res, track, nums, k, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//withdraw this option</span></span><br><span class="line">            track.remove(track.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 78. Subsets</title>
    <url>/2020/09/06/leetcode-78-subsets/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><em>Input: nums = [1,2,3]<br>Output:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</em></p>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><img src="/images/subsets.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">Backtracking can be solved always as follows:</span></span><br><span class="line"><span class="comment">Pick a starting point.</span></span><br><span class="line"><span class="comment">while(Problem is not solved)</span></span><br><span class="line"><span class="comment">    For each path from the starting point.</span></span><br><span class="line"><span class="comment">        check if selected path is safe, if yes select it</span></span><br><span class="line"><span class="comment">        and make recursive call to rest of the problem</span></span><br><span class="line"><span class="comment">        before which undo the current move.</span></span><br><span class="line"><span class="comment">    End For</span></span><br><span class="line"><span class="comment">If none of the move works out, return false, NO SOLUTON.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//input</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 80. Remove Duplicates from Sorted Array II</title>
    <url>/2020/09/06/leetcode-80-remove-duplicates/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a sorted array nums, remove the duplicates in-placesuch that duplicates appeared at most twice and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><em>
Given nums = [1,1,1,2,2,3],

<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</em></p>
<a id="more"></a>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p><em>Given nums = [0,0,1,1,1,1,2,3,3],</p>
<p>Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.</p>
<p>It doesn’t matter what values are set beyond the returned length.</em></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two pointer solution</span></span><br><span class="line"><span class="comment"> * with O(1) space complexity</span></span><br><span class="line"><span class="comment"> * and O(n) time complexity</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt =  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[slow] == nums[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt  &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    nums[++slow] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                nums[++slow] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 90. Subsets II</title>
    <url>/2020/09/06/leetcode-90-subset2/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><em>
Input: [1,2,2]<br />
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]</em>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//sorting the input numbers</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//call backtrack method</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; track, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">//add to res;</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(track));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//eliminate invalid options</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//pick a option</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            <span class="comment">//tracking</span></span><br><span class="line">            backtrack(res, track, nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//withdraw picked option</span></span><br><span class="line">            track.remove(track.size() - <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 88. Merge Sorted Array</title>
    <url>/2020/09/13/leetcode-88-merge-sorted-array/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul>
<li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li>
<li>You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>Output: [1,2,2,3,5,6]</p>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = m + n -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tail1 &gt;= <span class="number">0</span> &amp;&amp; tail2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            nums1[end--] = nums1[tail1] &lt; nums2[tail2] ? nums2[tail2--] : nums1[tail1--];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(tail2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            nums1[end--] = nums2[tail2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 92. Reverse Linked List II</title>
    <url>/2020/09/12/leetcode-92-reverse-linkedlist-2/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Reverse a linked list from position m to n. Do it in one-pass.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br><br>Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iterative solution</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// move the two pointers until they reach the proper starting point;</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//the two pointers that will fix the final connection</span></span><br><span class="line">        ListNode con = prev, tail = cur;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Iteratively reverse the nodes until n become 0;</span></span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(con != <span class="keyword">null</span>)&#123;</span><br><span class="line">            con.next = prev;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//recursive solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object level variables since we need the changes</span></span><br><span class="line">    <span class="comment">// to persist across recursive calls and Java is pass by value.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> stop;</span><br><span class="line">    <span class="keyword">private</span> ListNode left;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurseAndReverse</span><span class="params">(ListNode right, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case. Don&#x27;t proceed any further</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving the right pointer one step forward until (n == 1)</span></span><br><span class="line">        right = right.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving left pointer to the right until we reach the proper node</span></span><br><span class="line">        <span class="comment">// from where the reversal is to start.</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recurse with m and n reduced.</span></span><br><span class="line">        <span class="keyword">this</span>.recurseAndReverse(right, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In case both the pointers cross each other or become equal, we</span></span><br><span class="line">        <span class="comment">// stop i.e. don&#x27;t swap data any further. We are done reversing at this</span></span><br><span class="line">        <span class="comment">// point.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left == right || right.next == <span class="keyword">this</span>.left) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stop = <span class="keyword">true</span>;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Until the boolean stop is false, swap data between the two pointers</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.stop) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">this</span>.left.val;</span><br><span class="line">            <span class="keyword">this</span>.left.val = right.val;</span><br><span class="line">            right.val = t;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move left one step to the right.</span></span><br><span class="line">            <span class="comment">// The right pointer moves one step back via backtracking.</span></span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = head;</span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.recurseAndReverse(head, m, n);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 93. Restore IP Addresses</title>
    <url>/2020/09/19/leetcode-93-restore-ip-address/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.</p>
<p>A valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single dots and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are valid IP addresses and “0.011.255.245”, “192.168.1.312” and “<a href="mailto:&#49;&#x39;&#x32;&#x2e;&#49;&#54;&#56;&#x40;&#x31;&#46;&#x31;">&#49;&#x39;&#x32;&#x2e;&#49;&#54;&#56;&#x40;&#x31;&#46;&#x31;</a>“ are invalid IP addresses. </p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;0000&quot;</span><br><span class="line">Output: [&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;1111&quot;</span><br><span class="line">Output: [&quot;1.1.1.1&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;010010&quot;</span><br><span class="line">Output: [&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5"></a>Example 5</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s &#x3D; &quot;101023&quot;</span><br><span class="line">Output: [&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtracking(s, res, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String s, List&lt;String&gt; res, StringBuilder sb, <span class="keyword">int</span> index, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; s.length() || level &gt; <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index == s.length() &amp;&amp; level == <span class="number">4</span>)&#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index + i &gt; s.length()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> num = Integer.valueOf(s.substring(index, index + i));</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> || i==<span class="number">2</span> &amp;&amp; num &gt;=<span class="number">10</span> &amp;&amp; num &lt;=<span class="number">99</span> || i == <span class="number">3</span> &amp;&amp; num &gt;= <span class="number">100</span> &amp;&amp; num &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                sb.append(num);</span><br><span class="line">                <span class="keyword">if</span>(level &lt; <span class="number">3</span>) sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                backtracking(s,res,sb,index+i,level+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(level &lt; <span class="number">3</span>) sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">                sb.delete(sb.length()-i,sb.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode] 94. Binary Tree Inorder Traversal</title>
    <url>/2020/09/06/leetcode-94-binary-tree-inorder/</url>
    <content><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><em>
Input: [1,null,2,3]
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
Output: [1,3,2]<br />
Follow up: Recursive solution is trivial, could you do it iteratively?</em>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//recursive solution</span></span><br><span class="line">**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"> *     <span class="keyword">int</span> val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line"> *     TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         <span class="keyword">this</span>.val = val;</span><br><span class="line"> *         <span class="keyword">this</span>.left = left;</span><br><span class="line"> *         <span class="keyword">this</span>.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        inorder(node.left, res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        inorder(node.right, res); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//iterative solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();  </span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> res; </span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode cur = root;</span><br><span class="line">       <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           cur = stack.pop();</span><br><span class="line">           res.add(cur.val);</span><br><span class="line"></span><br><span class="line">           cur = cur.right;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
</search>
